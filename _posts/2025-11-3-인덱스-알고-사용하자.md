---
title: SNS 개인 프로젝트 - (3) 인덱스 알고 사용하자!
description: 인덱스의 종류에 대해 알아보고, 프로젝트에 인덱스 적용하기
author: youngmin
date: 2025-11-3 11:40:00 +0900
categories: [Backend, Project]
tags: [project]
pin: true
math: true
mermaid: true
# image:
#   path: /commons/devices-mockup.png
#   lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
#   alt: Responsive rendering of Chirpy theme on multiple devices.
---

지난 포스팅에서는 SNS 프로젝트의 기능들을 모놀리식으로 “정말 구현만” 한 코드들을 살펴보았다.

이번 포스팅에서는 데이터베이스 엔진에 따른 데이터 저장 방식에 대해 설명하고, 읽기 성능 개선을 위한 인덱스를 설정한다.

## 데이터베이스 엔진에 따른 데이터 저장 방식

사실 인덱스를 설명하는 데에 있어서 **데이터 중심 애플리케이션 설계 3장** 만한 것이 없다.

따라서 데중애설 3장 내용을 정리해본다.

먼저, 왜 인덱스가 필요한지에 대해 알아보자.

세상에서 가장 간단한 DB를 구현했다고 가정한다면,

```
set 1, {name: "유저 1", email: "user1@gmail.com"}
set 2, {name: "유저 2", email: "user2@gmail.com"}
```
이런 식으로 계속 데이터를 저장해 나갈 수 있다.

```
[저장 파일 예시]

1, {name: "유저 1", email: "user1@gmail.com"}
2, {name: "유저 2", email: "user2@gmail.com"}
```

이렇게 밑으로 계속 row 하나씩을 계속 쌓아 나가는 것은 저장 공간이 충분한 경우 굉장히 효율적이다.

이런 식으로 데이터베이스 엔진 내부적으로 사용하는 추가 전용 데이터 파일을 **로그** 라고 한다.

> 애플리케이션에서 사용하는 로그와는 다른 개념!

계속 추가만 되는 저장 구조에서는 같은 키 값에 대해 수정하는 로그도 있을 수 있다.

```
[저장 파일 예시]

1, {name: "유저 1", email: "user1@gmail.com"}
2, {name: "유저 2", email: "user2@gmail.com"}
...
1, {name: "수정 유저 1", email: "user1@gmail.com"}
```

이와 같은 경우 1 키 값의 마지막 row가 최신 데이터가 된다.

다만 이렇게 쌓아가다 보면 데이터를 조회하는 데에 문제가 발생한다.
```
[저장 파일 예시]

1, {name: "유저 1", email: "user1@gmail.com"}
2, {name: "유저 2", email: "user2@gmail.com"}
...
100000, {name: "유저 100000", email: "user100000@gmail.com"}
```

`get 100001`와 같이 저장 파일에서 100001 키 값을 가진 레코드를 찾기위해 매번 순차적으로 탐색해야하며, 

이는 O(N)의 복잡도를 가지게 된다.

따라서 특정 키의 값을 효율적으로 탐색하기 위해서는 **인덱스, 색인** 이라는 것이 필요하다.

### 해시 색인
![Desktop View](/posts/p3_1.png){: width="972" height="589" .w-75 .normal}

해시 색인은 메모리에 키 값과 디스크 주소를 매핑한 해시 맵을 유지하고, 한 번의 디스크 검색으로 데이터를 가져오는 방식이다.

데이터(로그)가 추가되면, 해시 맵을 갱신해주는 작업이 필요하다.

![Desktop View](/posts/p3_2.png){: width="972" height="589" .w-75 .normal}

계속 데이터가 추가되는 경우 발생할 수 있는 저장소 공간 부족 문제 해결을 위해 로그의 저장 단위를 특정 크기의 세그먼트로 정하고, 해당 세그먼트가 가득 찰 경우, 새로운 세그먼트에 쓰기 시작한다. 

이후 이전 세그먼트들의 로그에서 중복된 키 값을 제거하고, 최신 값으로 유지하는 과정인 “컴팩션”을 백그라운드에서 진행한다.

해시 색인 방식은 사실 일반적으로 사용하는 데이터베이스에서는 잘 사용하지 않는 방식이다.

메모리에 키 값을 전부 저장하기 때문에 키 값이 많아지면 성능에 제한이 있을 수 있고, 범위 쿼리 실행 시에는 각 키-값을 모두 비교해야 하므로 성능이 좋지 않다.

따라서 해시 색인 방식은 키에 해당하는 값이 자주 변경되면서, 키가 많지 않은 경우 사용하는 것이 바람직하다.

### LSM 트리

해시 색인에서 설명한 세그먼트-컴팩션 방식의 파일 구조에서 키 값을 정렬하여 가지고 있는 방식을 **Sorted String Table, SSTable** 이라고 말한다.

![Desktop View](/posts/p3_3.png){: width="972" height="589" .w-75 .normal}

컴팩션 과정이 디스크에 있는 SSTable이 (수정된 로그로 인한) SSTable 내에서 중복된 키 값을 가지고 있지 않도록 보장한다.

(컴팩션 과정에서의 정렬은 Merge Sort와 비슷하게 진행되지만 자세한 내용은 생략..)

![Desktop View](/posts/p3_4.png){: width="972" height="589" .w-75 .normal}

SSTable도 읽기 요청을 처리하기 위해 메모리 상에 인덱스는 필요하지만, 해당 세그먼트 내의 블록의 주소를 나타내는 Sparse Index를 사용하여 해시 색인보다 더 적은 용량으로 메모리 상에 인덱스를 가지고 있을 수 있다.

> Sparse Index는 세그먼트 별로 메모리에 로드되어 있음!
{: .prompt-info }

데이터의 추가/수정은 키 값의 순서와 상관이 없이 실행될 수 있기 때문에 SSTable을 생성할 시에는 메모리 상에서 트리 구조의 멤테이블에 정렬을 유지하고, 일정 크기가 되면 디스크에 세그먼트로 저장한다.

이 세그먼트는 가장 최신 세그먼트가 된다.

읽기 요청이 들어오는 경우에는 멤테이블 → 최신 세그먼트 → 그 다음 최신 세그먼트 … 순으로 키를 탐색한다.

이러한 인덱스 구조를 Log-Structured Merged-Tree, LSM 트리 라고 한다.

LSM 트리 방식은 엘라스틱 서치의 검색 엔진인 루씬에서 사용된다.

위와 같은 방식으로 동작한다고 할 때, 없는 데이터를 조회하려고 하면 가장 오래된 세그먼트까지 거슬러 올라가야한다는 단점이 있으므로, 블룸 필터라는 데이터 구조를 같이 사용한다.

다만, 순차적으로 쓰기를 처리하므로 높은 쓰기 처리량을 보장할 수 있다.

### B 트리

사실 B트리를 얘기하기 위해 앞선 두 가지를 설명했다.

B트리만 설명하기는 좀 아쉬우니까..

B트리도 마찬가지로 키가 정렬된 형태로 데이터를 유지하므로 읽기 요청에 효율적이다.

LSM 트리에서의 세그먼트는 가변 크기였지만, B트리는 고정된 크기의 블록 또는 페이지를 사용한다.

각 페이지는 주소로 식별할 수 있으며, 하나의 페이지에서 다른 페이지를 참조할 수 있다.

![Desktop View](/posts/p3_5.png){: width="972" height="589" .w-75 .normal}

가장 최상단에 있는 페이지를 **루트 페이지**라 하며, 조회 요청이 들어오면 각 하위 페이지들을 통해 실제 값이 있는 페이지(**리프 페이지**)로 도달하게 된다.

![Desktop View](/posts/p3_6.png){: width="972" height="589" .w-75 .normal}

새로운 키가 추가되어 페이지 분리가 필요한 경우에는 (위 그림 참고)

- 키를 추가하기 위하여 해당 페이지로 이동
- 해당 페이지에 여유 공간이 있으면 페이지에 그대로 추가
- 페이지에 여유 공간이 없으면 반 쯤 채워진 새로운 두 개의 페이지를 생성하여 참조시킨다.

이를 통해 트리가 계속 균형 상태를 유지하도록 보장한다.

일반적으로 B 트리는 LSM 트리보다 읽기에서 성능이 더 좋다고 할 수 있다.

(LSM 트리는 상위 세그먼트로 찾아가는 일련의 과정들이 필요하므로)

위 세 가지의 인덱스 구조는 키-값 색인이고, 대표적으로 RDB의 기본키(Primary key)의 인덱스로 사용된다.

보조 인덱스 (Secondary Index) 또한 키-값 색인으로 쉽게 만들 수 있지만 PK 인덱스와의 차이는 키 값이 유일하지 않다는 것이다.

### 클러스터드 인덱스

인덱스에서의 키는 쿼리가 검색하는 대상이지만 값은 실제 그 값이거나 값을 가리키는 참조이다.

참조 방식의 경우 실제 로우가 저장된 곳을 **힙 파일 (heap file)** 이라고 한다.

힙 파일 접근 방식은 결국 힙 파일과 색인을 이동하는 일이 잦으므로 성능 상 불이익이 있을 수 있다.

따라서 색인 내에 로우를 바로 저장하는 것을 클러스터드 인덱스이라고 한다.

mysql의 기본키는 언제나 클러스터드 인덱스이고, 보조 인덱스(Secondary Index)는 힙 파일이 아닌 기본키를 가리킨다.

### 결합 색인

위에서 설명한 것들은 모두 하나의 키만 값에 대응한 것이었다.

위 방법들은 테이블의 다중 컬럼에 대해 쿼리를 해야한다면 충분하지 않다.

따라서 다중 컬럼 색인이 필요한데, 가장 일반적으로 결합 색인이 있다.

결합 색인은 하나의 키에 여러 필드를 단순 결합하는 구조이다.

결합 색인을 어떤 방식으로 구현하던 정렬된 키 값으로 정렬되어 있다.

따라서 (성, 이름) 을 키로 가지는 결합 색인이라면, 성, 이름을 포함하는 질의는 물론이며, 성만을 포함하는 질의에도 결합 색인을 사용할 수 있다.

다만, 이름만을 포함하는 질의에는 해당 결합 색인을 사용할 수 없다.

또한, 배달 앱이나 지도 앱과 같은 경우에서 특정 area의 레스토랑들을 검색하는 쿼리를 작성한다고 할 때,

```
SELECT * FROM restaurants WHERE latitude > 51.4946 AND latitude < 51.5079
AND longitude > -0.1162 AND longitude < -0.1004;
```

B트리나 LSM 트리는 위와 같은 여러 개의 필드에 대하여 범위 질의를 하는 것에 효율적으로 응답하기 어렵다.

특정 위도 범위 안의 모든 레스토랑, 특정 경도 범위 안의 모든 레스토랑을 검색하는 것은 효율적일 수 있지만, 동시에 하는 것은 어렵다.

이런 경우 R트리와 같은 전문 공간 색인을 사용하는 것이 더 좋다.

(R트리에 대한 내용은 추후 포스팅에서 기회가 되면 다룰 수 있으면 좋겠다..)


## 기존 코드의 문제점

### 회원 가입 시의 성능 문제

**기존 유저 엔티티**
``` kotlin
@Entity
@Table(name = "users")
class User (
    @Id @GeneratedValue(strategy = GenerationType.IDENTITY)
    val id: Long? = null,

    @Column(nullable = false)
    var email: String,

    @Column(nullable = false)
    var name: String,

    @Column(nullable = false)
    var password: String,
)
```

**유저 조회하기 서비스 코드**
``` kotlin
@Transactional
fun register(req: UserRegisterRequestDto): AuthResult {
    // 이메일 중복 체크
    if (userRepository.findByEmail(req.email) != null) {
        throw ConflictException(
            errorCode = ErrorCode.ROW_ALREADY_EXIST,
            message = "중복된 이메일 입니다.",
        )
    }

    // 비밀번호 암호화 & 유저 저장
    val user = userRepository.save(
        User(
            email = req.email,
            name = req.name,
            password = passwordEncoder.encode(req.password),
        )
    )
    
    ...
    
}
```

mysql을 사용하는 프로젝트에서, 앞서 알아본 것 처럼 User 테이블은 ID를 키로 가지는 클러스터드 인덱스로 구성되어 있다.

따라서 ID로 검색하는 질의의 경우에는 성능에 문제가 없지만, 위와 같이 이메일 주소 중복 체크를 위하여 유저를 이메일 주소로 조회하는 쿼리를 실행한다고 하면, 인덱스가 적용되지 않은 O(N)의 복잡도를 가지게 될 것이다.

![Desktop View](/posts/p3_7.png){: width="972" height="589" .w-75 .normal}

유저 100000을 찾기 위해 User 테이블을 모두 뒤지게 될 것이고, 이는 User 테이블의 규모가 커질 수록 점점 더 성능이 악화된다.

**변경된 유저 엔티티**
``` kotlin
@Entity
@Table(
    name = "users",
    indexes = [
        Index(name = "idx_email", columnList = "email")
    ]
)
class User (
    @Id @GeneratedValue(strategy = GenerationType.IDENTITY)
    val id: Long? = null,

    @Column(nullable = false, unique = true)
    var email: String,

    @Column(nullable = false)
    var name: String,

    @Column(nullable = false)
    var password: String,
)
```

위와 같이 간단한 인덱스 설정만으로 쿼리의 성능 향상을 기대할 수 있다.

추가적으로, email은 유저 별로 고유해야 하므로 unique constraints를 추가해줬다.

### 팔로우 엔티티 관련 성능 문제

이번엔 조금 더 심화된 인덱스에 대해 살펴보자.

**기존 팔로우 엔티티**
``` kotlin
@Entity
@Table(name = "follow")
class Follow (
    @Id @GeneratedValue(strategy = GenerationType.IDENTITY)
    val id: Long? = null,

    @Column(nullable = false)
    var followerId: Long,

    @Column(nullable = false)
    var followingId: Long,
)
```

**언팔로우 서비스 코드**
``` kotlin
@Transactional
fun unfollowUser(userId: Long, req: FollowRequestDto) {
    val follower = userRepository.findByIdOrNull(userId)

    if (follower == null) {
        throw UnauthorizedException(
            ErrorCode.USER_NOT_FOUND, "유저가 존재하지 않습니다."
        )
    }

    val following = userRepository.findByIdOrNull(req.followingId)

    if (following == null) {
        throw NotFoundException(
            ErrorCode.ROW_NOT_FOUND, "유저가 존재하지 않습니다."
        )
    }

    val follow = followRepository.findByFollowerIdAndFollowingId(
        follower.id!!, following.id!!
    )

    if (follow == null) {
        throw NotFoundException(
            ErrorCode.ROW_NOT_FOUND, "팔로우한 유저가 아닙니다."
        )
    }

    followRepository.delete(follow)
}
```

follow 여부를 검증하기 위해 follow를 찾을 때, `followRepository.findByFollowerIdAndFollowingId` 함수를 실행한다.

해당 함수에서 실행되는 쿼리는 다음과 같다.

```
SELECT * FROM follow f WHERE f.followerId = {follower.id} 
AND f.followingId = {following.id};
```

앞서 설명했던 (성, 이름)의 사례처럼, 두 개 이상의 컬럼에 대한 질의 성능을 높이기 위해선 결합 인덱스를 사용한다.

따라서, (followerId, followingId) 를 키로 갖는 결합 인덱스를 구성한다.

또한, 팔로우 엔티티는 팔로워 유저 목록, 팔로잉 유저 목록, 팔로워 수, 팔로잉 수를 조회하는 것과 같이 followerId와 followingId 각각에 대해서도 질의를 수행한다.

**쿼리 함수 예시 1) 팔로워 수, 팔로잉 수 가져오기**
``` kotlin
val followingCount = followRepository.countByFollowerId(followerId = findUser.id!!)
val followerCount = followRepository.countByFollowingId(followingId = findUser.id!!)
```

따라서 팔로우 엔티티에 (followerId, followingId) 를 키로 갖는 결합 인덱스를 구성한 후, 이는 followerId 로 검색하는 질의에는 사용할 수 있는 인덱스이기 때문에 followingId에 대한 인덱스만 추가한다.

(followerId에 대한 인덱스를 따로 구성하지 않을 수 있다!)

**쿼리 함수 예시 2) 유저 아이디로 팔로워 목록 가져오기**
``` kotlin
@Query("SELECT f FROM Follow f WHERE f.followingId = :followingId ORDER BY f.id DESC LIMIT :limit")
fun findByFollowingIdOrderByIdDesc(followingId: Long, limit: Int): List<Follow>


val follows = if (cursor == null) {
    followRepository.findByFollowingIdOrderByIdDesc(user.id!!, size + 1)
} else {
    followRepository.findByFollowingIdAndIdLessThanOrderByIdDesc(user.id!!, cursor, size + 1)
}
```

팔로워 목록 서비스의 경우 followingId로 검색하지만, id로 DESC 정렬하는 쿼리를 실행한다.

따라서 여기에는 followingId 단일 인덱스보다는 (followingId, id) 의 복합 인덱스가 필요하다.

최종적으로, 아래와 같이 인덱스를 구성할 수 있다.

**변경된 팔로우 엔티티**
``` kotlin
@Entity
@Table(
    name = "follow",
    indexes = [
        Index(name = "idx_follower_id", columnList = "followerId, id DESC"),
        Index(name = "idx_following_id", columnList = "followingId, id DESC"),
        Index(name = "idx_follower_following", columnList = "followerId, followingId", unique = true)
    ]
)
class Follow (
    @Id @GeneratedValue(strategy = GenerationType.IDENTITY)
    val id: Long? = null,

    @Column(nullable = false)
    var followerId: Long,

    @Column(nullable = false)
    var followingId: Long,
)
```

(followerId, id) 인덱스는 팔로잉 목록 조회뿐만 아니라 팔로잉 수 조회에도 사용할 수 있다.

(followingId, id) 인덱스도 마찬가지이다.

이러한 배경들을 통해 모든 도메인 엔티티에 인덱스들을 적용하였다!

## 마치며

사실 인덱스로 하나의 포스팅을 모두 쓰는 것이 조금은 적은 내용이지 않을까 고민했다.

대부분의 사람들은 인덱스에 대해 단지 검색 성능을 높여주는 것이라고 설명한다.

실제로 코드에 적용하는 것도 몇 줄만 작성하면 가능하다.

하지만 앞서 설명했던 것들 처럼 인덱스에는 DB 엔진들의 저장 구조와 관련된 깊은 내용들이 숨어있다.

이를 알고 인덱스를 적용하는 것과 기계적으로 인덱스를 적용하는 것에는 그래도 차이가 있지 않을까 싶어… 한 포스팅 전체를 인덱스로 작성해봤다.

포스팅 작성을 위해 다시 한 번 LSM 트리와 B 트리를 알아보는 것도 재밌었고,

데중애설은 나에게 GOAT 책이라는 것을 또 다시 한 번 깨달았다….

나에게 누군가 면접에서 인덱스가 무엇이냐고 물어본다면..

혹시 펜과 종이가 있냐고 대답할 것이다 ㅋㅋ

---
> 인덱스가 적용된 코드는 [여기](https://github.com/mini8709/SNS-Demo-Proejct/tree/issue%232)에서 확인하실 수 있습니다.
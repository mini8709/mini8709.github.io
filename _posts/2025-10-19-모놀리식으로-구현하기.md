---
title: SNS 개인 프로젝트 - (1) 모놀리식으로 구현하기
description: 모놀리식으로 구현한 SNS 애플리케이션을 간략히 살펴본다
author: youngmin
date: 2025-10-19 01:40:00 +0900
categories: [Backend, Project]
tags: [project]
pin: true
math: true
mermaid: true
# image:
#   path: /commons/devices-mockup.png
#   lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
#   alt: Responsive rendering of Chirpy theme on multiple devices.
---

한 스타트업이 SNS 애플리케이션을 이제 막 개발하기 시작했다고 가정해보자.

스타트업의 초기 애플리케이션의 경우 안정성, 확장성을 고려하기 보다는 속도를 우선시 하기 마련이다.

이번 포스트에서는 SNS 애플리케이션의 기능들을 모놀리식 구조로 “정말 구현만” 한 내용을 정리한다.

## 모놀리식 프로젝트 구성 내용

### 프로젝트 스펙

Kotlin
Spring Boot 3.5.6
Spring Data JPA
mysql 8.3

### 프로젝트 구조

빠른 개발을 위해 초기 프로젝트 구조는 모놀리식 계층형 아키텍처를 선택했다.

```
  📦 SNS Application
  │
  ├─ 📱 Presentation Layer (Controller)
  │  ├─ AuthController          → 회원가입/로그인/로그아웃/토큰갱신
  │  ├─ UserController          → 유저 정보 조회
  │  ├─ FollowController        → 팔로우/언팔로우, 팔로워/팔로잉 목록
  │  └─ FeedController          → 피드 CRUD, 댓글 CRUD, 좋아요 CRUD
  │
  ├─ 🎯 Business Layer (Service)
  │  ├─ AuthService             → JWT 인증 로직
  │  ├─ UserService             → 유저 비즈니스 로직
  │  ├─ FollowService           → 팔로우 비즈니스 로직
  │  └─ FeedService             → 피드/댓글/좋아요 비즈니스 로직
  │
  ├─ 💾 Data Access Layer (Repository)
  │  ├─ UserRepository          → User 조회
  │  ├─ RefreshTokenRepository  → RefreshToken 조회/저장
  │  ├─ FollowRepository        → Follow 조회/저장
  │  ├─ FeedRepository          → Feed 조회/저장
  │  ├─ FeedImageRepository     → FeedImage 조회/저장/삭제
  │  ├─ CommentRepository       → Comment 조회/저장/삭제
  │  └─ LikeRepository          → Like 조회/저장/삭제
  │
  ├─ 🗂️ Domain Layer (Entity)
  │  ├─ User                    
  │  ├─ RefreshToken            
  │  ├─ Follow                  
  │  ├─ Feed                    
  │  ├─ FeedImage               
  │  ├─ Comment                 
  │  └─ Like                    
  │
  ├─ 📦 DTOs
  │  ├─ controller/dto/request/  → API 요청 DTO
  │  ├─ controller/dto/response/ → API 응답 DTO
  │  └─ service/dto/             → Service 계층 DTO
  │
  ├─ 🔐 Security & Config
  │  ├─ SecurityConfig          → Spring Security 설정
  │  ├─ JwtTokenProvider        → JWT 생성/검증
  │  ├─ JwtAuthenticationFilter → JWT 필터
  │  └─ GlobalExceptionHandler  → 전역 예외 처리
  │
  ├─ 🛠️ Common
  │  └─ pagination/
  │     └─ CursorPaginated<T>  → Cursor 페이지네이션
```
<!-- markdownlint-capture -->
> 클로드야 정리해줘서 고마워..
{: .mt-4 .mb-10 }

마이크로서비스 패턴 1장에서는 초기 애플리케이션에서의 모놀리식 아키텍처의 장점을 다음과 같이 설명한다.
{: .mt-12 .mb-0 }
- 개발이 간단하다.
- 애플리케이션을 쉽게 변경할 수 있다.
- 테스트 하기 쉽다.
- 배포하기 쉽다.
    - 인스턴스에 접속해서 war 파일만 실행하면 끝!
- 확장하기 쉽다.
    - 로드밸런서 뒤에 인스턴스만 여러 개로 확장해주면 끝!

장점들을 하나하나 읽어봐도 알 수 있듯이 초기 스타트업이 빠르게 서비스를 개발하는 데에 가장 적합한 아키텍처라고 생각한다.

계층형 아키텍처는 3개의 계층으로 구성했다.
{: .mt-4 .mb-0 }
- Presentation Layer
    - Controller가 이에 해당
- Domain / Business Layer
    - Entity, Service가 이에 해당
- Data Access Layer
    - Repository가 이에 해당

계층형 아키텍처의 장점은 관심사에 따라 Layer를 분리하기 때문에 코드 가독성이 좋아진다는 것이다.

- DB에 접근하는 코드들만 모아두고 싶어! ⇒ Data Access Layer
- 비즈니스 로직에 관련된 코드들만 모아두고 싶어! ⇒ Domain / Business Layer

또, 무엇보다 가장 익숙한 구조이기 때문에 편리하다!

모놀리식 아키텍처, 계층형 아키텍처에는 다른 단점들이 존재하지만, 추후 마이크로 서비스, 육각형 아키텍처로 변경하는 포스팅에서 이를 좀 더 자세히 다뤄보려고 한다.


## 몇몇 코드들 알아보기

앞서 얘기했던 것처럼 “이제 막 개발하기 시작한 단계” 라는 것을 염두에 두고 코드들을 살펴본다.

### User Entity와 관련된 문제들

```kotlin
@Entity
@Table(name = "users")
class User (
    @Id @GeneratedValue(strategy = GenerationType.IDENTITY)
    val id: Long? = null,

    @Column(nullable = false)
    var email: String,

    @Column(nullable = false)
    var name: String,

    @Column(nullable = false)
    var password: String,

)
```

현재 User Entity에는 어떠한 Index나 Constraints도 설정하지 않은 상태이다.

이 경우 회원 가입 시 문제가 발생할 수 있다.

```kotlin
@Transactional
fun register(req: UserRegisterRequestDto): AuthResult {
    // 이메일 중복 체크
    if (userRepository.findByEmail(req.email) != null) {
        throw ConflictException(
            errorCode = ErrorCode.ROW_ALREADY_EXIST,
            message = "중복된 이메일 입니다.",
        )
    }

    // 비밀번호 암호화 & 유저 저장
    val user = userRepository.save(
        User(
            email = req.email,
            name = req.name,
            password = passwordEncoder.encode(req.password),
        )
    )

    // 토큰 생성
    val accessToken = jwtTokenProvider.generateAccessToken(user.id!!)
    val refreshToken = jwtTokenProvider.generateRefreshToken(user.id!!)

    // Refresh Token DB에 저장
    refreshTokenRepository.save(
        RefreshToken(
            userId = user.id!!,
            token = refreshToken,
            expiresAt = LocalDateTime.now().plusDays(7)
        )
    )

    return AuthResult(user, accessToken, refreshToken)
}
```

email에 대해 인덱스가 설정되지 않았으므로 유저가 많아진 경우, `userRepository.findByEmail` 쿼리 시 성능 상 문제가 발생할 수 있다.

또, Unique Constraints가 설정되지 않았으므로 애플리케이션 로직만으로 이메일 중복을 체크한다면 동시성 문제가 발생할 수 있다.

이러한 문제들은 추후 성능 개선에 관한 포스팅이나 동시성 문제 해결에 관한 포스팅에서 좀 더 자세히 다뤄보려 한다.

### Feed, FeedImage의 애매모호함

```kotlin
@Entity
@Table(name = "feed")
class Feed (
    @Id @GeneratedValue(strategy = GenerationType.IDENTITY)
    val id: Long? = null,

    @Column(nullable = false)
    var writer: Long,

    @Column(nullable = false)
    var content: String,

    @Column(updatable = false)
    @CreatedDate
    var date: LocalDateTime? = null,
)
```

```kotlin
@Entity
@Table(name = "feed_image")
class FeedImage (
    @Id @GeneratedValue(strategy = GenerationType.IDENTITY)
    val id: Long? = null,

    @Column(nullable = false)
    var feedId: Long,

    @Column(nullable = false)
    var imgSrc: String,
)
```
(좀 억지인 감이 있지만) 정규화를 위해 피드와 피드 이미지들을 다른 테이블에 두었다.

이 경우 성능 상 문제도 발생할 수 있고 개발하기도 굉장히 번거롭다.

```kotlin
@Transactional
fun createFeed(userId: Long, req: FeedCreateRequestDto): FeedResult {
    val user = userRepository.findByIdOrNull(userId)

    if (user == null) {
        throw UnauthorizedException(
            errorCode = ErrorCode.USER_NOT_FOUND,
            message = "유저가 존재하지 않습니다.",
        )
    }

    val feed = feedRepository.save(
        Feed(
            writer = user.id!!,
            content = req.content,
        )
    )

    val feedImgList = mutableListOf<FeedImage>()
    req.imageSrcList.forEach { src ->
        val feedImage = feedImageRepository.save(
            FeedImage(
                feedId = feed.id!!,
                imgSrc = src
            )
        )
        feedImgList.add(feedImage)
    }

    return FeedResult(
        feed = feed,
        feedImgList = feedImgList,
        writer = user,
        commentCount = 0,
        likeCount = 0
    )
}
```
피드 생성을 할 때 피드와 피드 이미지를 생성하는 N개의 쿼리가 필요하다.

피드 이미지들을 saveAll 하더라도 단 건의 쿼리보다는 성능이 낮을 수 밖에 없다.

조회는 더 불편하다.

```kotlin
@Transactional
fun getUserFeedList(userId: Long, targetUserId: Long, cursor: Long?, size: Int): FeedListResult {
    val user = userRepository.findByIdOrNull(userId)

    if (user == null) {
        throw UnauthorizedException(
            ErrorCode.USER_NOT_FOUND, "유저가 존재하지 않습니다."
        )
    }

    val targetUser = userRepository.findByIdOrNull(targetUserId)

    if (targetUser == null) {
        throw NotFoundException(
            ErrorCode.ROW_NOT_FOUND,
            "해당 유저가 존재하지 않습니다."
        )
    }

    val feeds = if (cursor == null) {
        feedRepository.findByWriterOrderByIdDesc(targetUser.id!!, size + 1)
    } else {
        feedRepository.findByWriterAndIdLessThanOrderByIdDesc(targetUser.id!!, cursor, size + 1)
    }

    val hasNext = feeds.size > size
    val items = if (hasNext) feeds.dropLast(1) else feeds
    val nextCursor = if (hasNext) items.last().id else null

    val feedIds = items.map { it.id!! }

    // 피드 이미지들을 batch로 가져오기
    val feedImages = feedImageRepository.findByFeedIdIn(feedIds)
    val feedImageGroups = feedImages.groupBy { it.feedId }

    // 댓글 수를 batch로 가져오기
    val commentCounts = commentRepository.countByFeedIdIn(feedIds)
    val commentCountMap = commentCounts.associate { it[0] as Long to it[1] as Long }

    // 좋아요 수를 batch로 가져오기
    val likeCounts = likeRepository.countByFeedIdIn(feedIds)
    val likeCountMap = likeCounts.associate { it[0] as Long to it[1] as Long }

    // FeedResult 리스트 생성
    val feedResults = items.map { feed ->
        FeedResult(
            feed = feed,
            feedImgList = feedImageGroups[feed.id] ?: emptyList(),
            writer = targetUser,
            commentCount = commentCountMap[feed.id] ?: 0,
            likeCount = likeCountMap[feed.id] ?: 0
        )
    }

    return FeedListResult(
        feedList = feedResults,
        nextCursor = nextCursor
    )
}
```

찾고 있는 피드 ID 리스트에 해당하는 모든 피드 이미지들을 가져와 feedId로 그룹화하여 해시맵으로 변경한 후 `feedImgList = feedImageGroups[feed.id] ?: emptyList()` 와 같은 코드로 가져와야 한다.

(최근의 RDB 들은 Json 타입을 지원하지만 연습을 위해..) 이를 해결하기 위해 NoSQL로 변경하여 Feed 테이블과 FeedImage 테이블을 아래 처럼 하나의 Collection으로 합친다면 어떨까?

```kotlin
class Feed (
    @Id @GeneratedValue(strategy = GenerationType.IDENTITY)
    val id: Long? = null,

    @Column(nullable = false)
    var writer: Long,

    @Column(nullable = false)
    var content: String,

    @Column(updatable = false)
    @CreatedDate
    var date: LocalDateTime? = null,

    @Column(nullable = false)
    var imgSrcList: List<String>,
)
```

N개의 쿼리가 필요하던 것은 하나의 쿼리로 해결할 수 있지만 이것도 마냥 쉬운 일은 아니다.

RDB와 NoSQL을 동시에 사용한다면
- 둘의 일관성을 강력하게 보장해야 한다면 어떻게 해야하지?
- 둘의 일관성은 일시적으로는 보장하지 않아도 되지만 최종적으로는 보장해줬으면 좋겠는데?

또 위와 같은 문제들을 마주하게 된다.

이러한 문제들은 추후 분산 트랜잭션, Outbox 패턴 적용 등의 포스팅에서 더 자세히 다뤄보려 한다.

## 마치며..

앞으로 수정해나가야 할 것들은 위에서 다룬 것들 뿐 아니라 정말 많은 것들이 있다.

앞선 포스팅에서 다뤘던 것처럼 굉장히 많은 유저들에게 피드를 fan-out 하는 방법들에 대해서도 고민해야 하고, 굉장히 많은 팔로워를 가진 유저의 팔로워 수를 Count 쿼리가 아니면 어떻게 가져와야 하고 이를 어떻게 보장해야 하는가에 대해서도 고민해야 한다.

천리 길도 한 걸음씩이라고.. 천천히 하나씩 꾸준히 해나가보자고 다짐해본다!

---
> 해당 포스팅 시점의 전체 코드는 [여기](https://github.com/mini8709/SNS-Demo-Proejct/tree/issue%231) 에서 볼 수 있습니다.